<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" 
   "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<section id="auth.parameters" xmlns:xi="http://www.w3.org/2001/XInclude">
    <sectioninfo>
	<revhistory>
	    <revision>
		<revnumber>$Revision: 1.6 $</revnumber>
		<date>$Date: 2008/01/24 13:34:23 $</date>
	    </revision>
	</revhistory>
    </sectioninfo>

    <title>Parameters</title>
    
    <section id="auth.auth_checks">
	<title>
	  <varname>auth_checks_register</varname>,
	  <varname>auth_checks_no_dlg</varname>, and
	  <varname>auth_checks_in_dlg</varname> (flags)
	</title>
	<para>
	    These three module parameters control which optional integrity
         checks will be performed on the SIP message carrying digest response
        during digest authentication. <varname>auth_check_register</varname>
        controls integrity checks to be peformed on REGISTER messages,
        <varname>auth_checks_no_dlg</varname> controls which optional
        integrity checks will be performed on SIP requests that have no To
        header field or no To tag (in other words the requests either
        establishing or outside
        dialogs). <varname>auth_checks_in_dlg</varname> controls which
        integrity checks will be performed on SIP requests within dialogs,
        such as BYE or re-INVITE. The default value for all three parameters
        is 0 (old behaviour, no extra checks). The set of integrity checks
        that can be performed on REGISTERs is typically different from sets of
        integrity checks that can be performed for other SIP request types,
        hence we have three independent module parameters.
	</para>
	<para>
		Without the extra checks the nonce will protect only against expired
		values. Some reply attacks are still possible in the expire "window".
		A possible workarround is to always force qop 
		 authentification and always check the uri from the authorization
		 header, but this would not work if an upstream proxy rewrites the uri
		 and it will also not work with a lot of UA implementations.
	</para>
	<para>
		In this case the nonce value will be used only to hold
		the expire time (see <varname>nonce_expire</varname>) and an MD5
		over it and some secret (the MD5 is used to make sure that nobody
		tampers with the nonce expire time).
	</para>
	<para>
		When the extra checks are enabled, the nonce will include and extra
		MD5 over the selected part/parts of the message (see below) and some 
		other secret. This will be used to check if the selected part of 
		the message is the same when an UA tries to reuse the nonce, thus 
		protecting or severely limiting reply attacks.
	</para>
	<para>
		The possible flag values all three parameters are: 1 for checking if
		the message uri changed (uses the whole uri), 2 for checking the
		callid, 4 for the from tag and 8 for the source ip (see nonce.h). For
		example setting
		 <varname>auth_checks_register</varname> to 6 would check if the
		 callid or the from tag changed from the REGISTER message for which
		 the original nonce was generated (this would allow nonce reuse only
		 within the same UA and for the expire time).  Note that enabling
		 the extra checks will limit nonce caching by UAs, requiring extra
		 challenges and roundtrips, but will provide much better protection.
	</para>
	<para>
		When the <varname>secret</varname> parameter is set and the extra
		checks are enabled, the first half of the <varname>secret</varname> 
		will be used for the expire time MD5 and the other half for the extra
		checks MD5, so make sure you have a long secret (32 chars or longer are
		recommended).
	</para>
	<example>
	    <title>Setting the <varname>auth_checks_register</varname> module 
				parameter</title>
	    <programlisting>
modparam("auth", "auth_checks_register", 2) # callid
	    </programlisting>
	</example>
    </section>

    <section id="auth.secret">
	<title><varname>secret</varname> (string)</title>
	<para>
	    Default value is randomly generated string.
	</para>
	<example>
	    <title>Setting secret module parameter</title>
	    <programlisting>
modparam("auth", "secret", "johndoessecretphrase")
	    </programlisting>
	</example>
    </section>
    
    <section id="nonce_expire">
	<title><varname>nonce_expire</varname> (integer)</title>
	<para>
	    Nonces have limited lifetime. After a given period of time nonces
	    will be considered invalid. This is to protect replay
	    attacks. Credentials containing a stale nonce will be not
	    authorized, but the user agent will be challenged again. This time
	    the challenge will contain <varname>stale</varname> parameter which
	    will indicate to the client that it doesn't have to disturb user by
	    asking for username and password, it can recalculate credentials
	    using existing username and password.
	</para>
	<para>
	    The value is in seconds and default value is 300 seconds.
	</para>
	<example>
	    <title>nonce_expire example</title>
	    <programlisting>
modparam("auth", "nonce_expire", 600)   # Set nonce_expire to 600s
	    </programlisting>
	</example>
    </section>
    
    <section id="rpid_prefix">
	<title><varname>rpid_prefix</varname> (string)</title>
	<para>
	    Prefix to be added to Remote-Party-ID header field just before the
	    URI returned from either radius or database.
	</para>
	<para>
	    Default value is "" (empty string).
	</para>
	<example>
	    <title>rpid_prefix</title>
	    <programlisting>
<![CDATA[
modparam("auth", "rpid_prefix", "Whatever <")
]]>
	    </programlisting>
	</example>
    </section>
    
    <section id="rpid_suffix">
	<title><varname>rpid_suffix</varname> (string)</title>
	<para>
	    Suffix to be added to Remote-Party-ID header field after the URI
	    returned from either radius or database.
	</para>
	<para>
	    Default value is ";party=calling;id-type=subscriber;screen=yes".
	</para>
	<example>
	    <title>rpid_suffix</title>
	    <programlisting>
<![CDATA[
modparam("auth", "rpid_suffix", "@1.2.3.4>")
]]>
	    </programlisting>
	</example>
    </section>
</section>
