diff -prNU5 cfg.y
--- cfg.y	2006-10-25 16:54:32.000000000 +0000
+++ cfg.y	2006-11-04 01:18:08.000000000 +0000
@@ -103,11 +103,11 @@
 #include "select.h"
 #include "flags.h"
 
 #include "config.h"
 #ifdef USE_TLS
-#include "tls/tls_config.h"
+/*#include "tls/tls_config.h"*/
 #endif
 
 #ifdef DEBUG_DMALLOC
 #include <dmalloc.h>
 #endif
@@ -713,11 +713,11 @@ assign_stm:
 		#endif
 	}
 	| DISABLE_TLS EQUAL error { yyerror("boolean value expected"); }
 	| TLSLOG EQUAL NUMBER {
 		#ifdef USE_TLS
-			tls_log=$3;
+		     /*tls_log=$3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLSLOG EQUAL error { yyerror("int value expected"); }
@@ -729,32 +729,32 @@ assign_stm:
 		#endif
 	}
 	| TLS_PORT_NO EQUAL error { yyerror("number expected"); }
 	| TLS_METHOD EQUAL SSLv23 {
 		#ifdef USE_TLS
-			tls_method=TLS_USE_SSLv23;
+		     /*tls_method=TLS_USE_SSLv23;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_METHOD EQUAL SSLv2 {
 		#ifdef USE_TLS
-			tls_method=TLS_USE_SSLv2;
+		     /*tls_method=TLS_USE_SSLv2;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_METHOD EQUAL SSLv3 {
 		#ifdef USE_TLS
-			tls_method=TLS_USE_SSLv3;
+		     /*tls_method=TLS_USE_SSLv3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_METHOD EQUAL TLSv1 {
 		#ifdef USE_TLS
-			tls_method=TLS_USE_TLSv1;
+		     /*tls_method=TLS_USE_TLSv1;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_METHOD EQUAL error {
@@ -764,59 +764,59 @@ assign_stm:
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_VERIFY EQUAL NUMBER {
 		#ifdef USE_TLS
-			tls_verify_cert=$3;
+		     /*tls_verify_cert=$3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_VERIFY EQUAL error { yyerror("boolean value expected"); }
 	| TLS_REQUIRE_CERTIFICATE EQUAL NUMBER {
 		#ifdef USE_TLS
-			tls_require_cert=$3;
+		     /*tls_require_cert=$3;*/
 		#else
 			warn( "tls support not compiled in");
 		#endif
 	}
 	| TLS_REQUIRE_CERTIFICATE EQUAL error { yyerror("boolean value expected"); }
 	| TLS_CERTIFICATE EQUAL STRING {
 		#ifdef USE_TLS
-			tls_cert_file=$3;
+		     /*tls_cert_file=$3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_CERTIFICATE EQUAL error { yyerror("string value expected"); }
 	| TLS_PRIVATE_KEY EQUAL STRING {
 		#ifdef USE_TLS
-			tls_pkey_file=$3;
+		     /*tls_pkey_file=$3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_PRIVATE_KEY EQUAL error { yyerror("string value expected"); }
 	| TLS_CA_LIST EQUAL STRING {
 		#ifdef USE_TLS
-			tls_ca_file=$3;
+		     /*tls_ca_file=$3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_CA_LIST EQUAL error { yyerror("string value expected"); }
 	| TLS_HANDSHAKE_TIMEOUT EQUAL NUMBER {
 		#ifdef USE_TLS
-			tls_handshake_timeout=$3;
+		     /*tls_handshake_timeout=$3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_HANDSHAKE_TIMEOUT EQUAL error { yyerror("number expected"); }
 	| TLS_SEND_TIMEOUT EQUAL NUMBER {
 		#ifdef USE_TLS
-			tls_send_timeout=$3;
+		     /*tls_send_timeout=$3;*/
 		#else
 			warn("tls support not compiled in");
 		#endif
 	}
 	| TLS_SEND_TIMEOUT EQUAL error { yyerror("number expected"); }
diff -prNU5 globals.h
--- globals.h	2006-10-25 18:44:36.000000000 +0000
+++ globals.h	2006-11-04 01:18:25.000000000 +0000
@@ -35,10 +35,11 @@
 
 #include "types.h"
 #include "ip_addr.h"
 #include "str.h"
 #include "poll_types.h"
+#include "transport.h"
 
 #define NO_DNS     0
 #define DO_DNS     1
 #define DO_REV_DNS 2
 
@@ -195,6 +196,8 @@ extern int use_dst_blacklist; /* 1 if th
 unsigned int  blst_max_mem; /* maximum memory used for the blacklist entries*/
 unsigned int blst_timeout; /* blacklist entry ttl */
 unsigned int blst_timer_interval; /* blacklist gc timer interval (in s)*/
 #endif
 
+extern transport_t* tls;
+
 #endif
diff -prNU5 main.c
--- main.c	2006-10-25 18:44:36.000000000 +0000
+++ main.c	2006-11-04 01:18:15.000000000 +0000
@@ -127,11 +127,11 @@
 #include "signals.h"
 #ifdef USE_TCP
 #include "poll_types.h"
 #include "tcp_init.h"
 #ifdef USE_TLS
-#include "tls/tls_init.h"
+/* #include "tls/tls_init.h" */
 #endif
 #endif
 #include "usr_avp.h"
 #include "core_cmd.h"
 #include "flags.h"
@@ -141,10 +141,11 @@
 #endif
 #ifdef USE_DST_BLACKLIST
 #include "dst_blacklist.h"
 #endif
 
+#include "transport.h"
 #include "stats.h"
 
 #ifdef DEBUG_DMALLOC
 #include <dmalloc.h>
 #endif
@@ -390,10 +391,11 @@ int ser_kill_timeout=DEFAULT_SER_KILL_TI
 
 /* cfg parsing */
 int cfg_errors=0;
 int cfg_warnings=0;
 
+transport_t* tls = 0;
 
 /* shared memory (in MB) */
 unsigned long shm_mem_size=SHM_MEM_SIZE * 1024 * 1024;
 
 /* export command-line to anywhere else */
@@ -431,11 +433,11 @@ void cleanup(show_status)
 #endif
 #ifdef USE_TCP
 	destroy_tcp();
 #endif
 #ifdef USE_TLS
-	destroy_tls();
+	     /*destroy_tls();*/
 #endif
 	destroy_timer();
 	destroy_script_cb();
 	destroy_routes();
 	destroy_atomic_ops();
@@ -956,18 +958,24 @@ int main_loop()
 		}
 #ifdef USE_TLS
 		if (!tls_disable){
 			for(si=tls_listen; si; si=si->next){
 				/* same as for tcp*/
+				/*
 				if (tls_init(si)==-1)  goto error;
+				*/
 				/* get first ipv4/ipv6 socket*/
+				/*
 				if ((si->address.af==AF_INET)&&
 						((sendipv4_tls==0)||(sendipv4_tls->flags&SI_IS_LO)))
 					sendipv4_tls=si;
+				*/
 		#ifdef USE_IPV6
+				/*
 				if((sendipv6_tls==0)&&(si->address.af==AF_INET6))
 					sendipv6_tls=si;
+				*/
 		#endif
 			}
 		}
 #endif /* USE_TLS */
 #endif /* USE_TCP */
@@ -1518,14 +1526,16 @@ try_again:
 		}
 	}
 #ifdef USE_TLS
 	if (!tls_disable){
 		/* init tls*/
+		/*
 		if (init_tls()<0){
 			LOG(L_CRIT, "could not initialize tls, exiting...\n");
 			goto error;
 		}
+		*/
 	}
 #endif /* USE_TLS */
 #endif /* USE_TCP */
 	/* init_daemon? */
 	if (!dont_fork){
diff -prNU5 tcp_main.c
--- tcp_main.c	2006-11-02 23:35:32.000000000 +0000
+++ tcp_main.c	2006-11-04 01:18:20.000000000 +0000
@@ -117,11 +117,11 @@
 #include "tcp_server.h"
 #include "tcp_init.h"
 #include "tsend.h"
 #include "timer_ticks.h"
 #ifdef USE_TLS
-#include "tls/tls_server.h"
+/* #include "tls/tls_server.h" */
 #endif 
 #include "tcp_info.h"
 
 #define local_malloc pkg_malloc
 #define local_free   pkg_free
@@ -433,11 +433,11 @@ struct tcp_connection* tcpconn_new(int s
 	c->rcv.proto_reserved2=0;
 	c->state=state;
 	c->extra_data=0;
 #ifdef USE_TLS
 	if (type==PROTO_TLS){
-		if (tls_tcpconn_init(c, sock)==-1) goto error;
+		if (tls && (tls->u.tcp.init(c, sock) == -1)) goto error;
 	}else
 #endif /* USE_TLS*/
 	{
 		c->type=PROTO_TCP;
 		c->rcv.proto=PROTO_TCP;
@@ -557,11 +557,12 @@ void _tcpconn_rm(struct tcp_connection* 
 	for (r=0; r<c->aliases; r++)
 		tcpconn_listrm(tcpconn_aliases_hash[c->con_aliases[r].hash], 
 						&c->con_aliases[r], next, prev);
 	lock_destroy(&c->write_lock);
 #ifdef USE_TLS
-	if (c->type==PROTO_TLS) tls_tcpconn_clean(c);
+	if (c->type==PROTO_TLS) 
+		if (tls) tls->u.tcp.clean(c);
 #endif
 	shm_free(c);
 }
 
 
@@ -576,11 +577,12 @@ void tcpconn_rm(struct tcp_connection* c
 		tcpconn_listrm(tcpconn_aliases_hash[c->con_aliases[r].hash], 
 						&c->con_aliases[r], next, prev);
 	TCPCONN_UNLOCK;
 	lock_destroy(&c->write_lock);
 #ifdef USE_TLS
-	if ((c->type==PROTO_TLS)&&(c->extra_data)) tls_tcpconn_clean(c);
+	if ((c->type==PROTO_TLS)&&(c->extra_data)) 
+		if (tls) tls->u.tcp.clean(c);
 #endif
 	shm_free(c);
 }
 
 
@@ -804,11 +806,15 @@ get_fd:
 send_it:
 	DBG("tcp_send: sending...\n");
 	lock_get(&c->write_lock);
 #ifdef USE_TLS
 	if (c->type==PROTO_TLS)
-		n=tls_blocking_write(c, fd, buf, len);
+		if (tls) {
+			n = tls->u.tcp.blocking_write(c, fd, buf, len);
+		} else {
+			n = -1;
+		}
 	else
 #endif
 		/* n=tcp_blocking_write(c, fd, buf, len); */
 		n=tsend_stream(fd, buf, len, tcp_send_timeout*1000); 
 	lock_release(&c->write_lock);
@@ -948,11 +954,11 @@ static void tcpconn_destroy(struct tcp_c
 				tcpconn, tcpconn->flags);
 		fd=tcpconn->s;
 #ifdef USE_TLS
 		/*FIXME: lock ->writelock ? */
 		if (tcpconn->type==PROTO_TLS)
-			tls_close(tcpconn, fd);
+			if (tls) tls->u.tcp.close(tcpconn, fd);
 #endif
 		_tcpconn_rm(tcpconn);
 		close(fd);
 		(*tcp_connections_no)--;
 	}else{
@@ -1608,11 +1614,11 @@ static inline void tcpconn_timeout(int f
 					DBG("tcpconn_timeout: timeout for hash=%d - %p"
 							" (%d > %d)\n", h, c, ticks, c->timeout);
 				fd=c->s;
 #ifdef USE_TLS
 				if (c->type==PROTO_TLS)
-					tls_close(c, fd);
+					if (tls) tls->u.tcp.close(c, fd);
 #endif
 				_tcpconn_rm(c);
 				if ((fd>0)&&(atomic_get(&c->refcnt)==0)) {
 					if (!(c->flags & F_CONN_REMOVED)){
 						io_watch_del(&io_h, fd, -1, IO_FD_CLOSING);
diff -prNU5 tcp_read.c
--- tcp_read.c	2006-11-02 22:55:56.000000000 +0000
+++ tcp_read.c	2006-11-04 01:18:08.000000000 +0000
@@ -60,11 +60,11 @@
 #include "globals.h"
 #include "receive.h"
 #include "timer.h"
 #include "ut.h"
 #ifdef USE_TLS
-#include "tls/tls_server.h"
+/*#include "tls/tls_server.h"*/
 #endif
 
 #define HANDLE_IO_INLINE
 #include "io_wait.h"
 #include <fcntl.h> /* must be included after io_wait.h if SIGIO_RT is used */
@@ -197,11 +197,12 @@ int tcp_read_headers(struct tcp_connecti
 	if (r->parsed<r->pos){
 		bytes=0;
 	}else{
 #ifdef USE_TLS
 		if (c->type==PROTO_TLS)
-			bytes=tls_read(c);
+			if (tls) bytes = tls->u.tcp.read(c);
+			else bytes = -1;
 		else
 #endif
 			bytes=tcp_read(c);
 		if (bytes<=0) return bytes;
 	}
@@ -515,14 +516,15 @@ int tcp_read_req(struct tcp_connection* 
 		resp=CONN_RELEASE;
 		s=con->fd;
 		req=&con->req;
 #ifdef USE_TLS
 		if (con->type==PROTO_TLS){
-			if (tls_fix_read_conn(con)!=0){
+			if (!tls || (tls->u.tcp.fix_read_con(con)!=0)){
 				resp=CONN_ERROR;
 				goto end_req;
 			}
+
 			if(con->state!=S_CONN_OK) goto end_req; /* not enough data */
 		}
 #endif
 
 again:
diff -prNU5 transport.h
--- transport.h	1970-01-01 00:00:00.000000000 +0000
+++ transport.h	2006-11-04 01:18:08.000000000 +0000
@@ -0,0 +1,77 @@
+/*
+ * $Id: tls-core.patch,v 1.3 2006/11/04 01:44:34 hallik Exp $
+ *
+ * Copyright (C) 2001-2003 FhG Fokus
+ *
+ * This file is part of ser, a free SIP server.
+ *
+ * ser is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * For a license to use the ser software under conditions
+ * other than those described here, or to purchase support for this
+ * software, please contact iptel.org by e-mail at the following addresses:
+ *    info@iptel.org
+ *
+ * ser is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _TRANSPORT_H
+#define _TRANSPORT_H
+
+#include "tcp_conn.h"
+
+
+typedef int (*tcp_init_f)(struct tcp_connection *c, int sock);
+typedef void (*tcp_clean_f)(struct tcp_connection *c);
+typedef void (*tcp_close_f)(struct tcp_connection *c, int fd);
+typedef size_t (*tcp_blocking_write_f)(struct tcp_connection *c, int fd, const char *buf, size_t len);
+typedef size_t (*tcp_read_f)(struct tcp_connection *c);
+typedef int (*tcp_fix_read_con_f)(struct tcp_connection *c);
+
+
+enum trans_flags {
+	TRANSPORT_SECURE = (1 << 0),  /* Transport is secure */
+	TRANSPORT_STREAM = (1 << 1),  /* Transport uses stream (reliable) sockets */
+	TRANSPORT_DGRAM = (1 << 2)    /* Transport uses datagram (unrealiable) sockets */
+};
+
+/* TCP related functions */
+struct tcp_func {
+	tcp_init_f           init;
+	tcp_clean_f          clean;
+	tcp_close_f          close;
+	tcp_blocking_write_f blocking_write; 
+	tcp_read_f           read;
+	tcp_fix_read_con_f   fix_read_con;
+};
+
+/* UDP related functions */
+struct udp_func {
+};
+
+
+/* Structure representing transports on top of TCP or UDP */
+typedef struct transport {
+	int proto;  /* Protocol ID */
+	str name;   /* Protocol name */
+	int flags;  /* Various flags */
+
+	union {
+		struct tcp_func tcp;
+		struct udp_func udp;
+	} u;
+	struct transport* next;
+} transport_t;
+
+
+#endif /* _TLS_H */
